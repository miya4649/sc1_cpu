* iCE40HX-8K(開発環境: IceStorm)版について
これはsc1_cpuをIceStormで実装して動作させるために改変したバージョンです。
Block RAMの出力にレジスタが追加され、パイプラインが深くなっています。
通常のsc1_cpuとは遅延スロット等の仕様が異なるためバイナリの互換性がありません。


* 実行方法
ターゲットボードはLattice iCE40HX-8K Breakout Board、開発環境はIceStorm用です。

Project IceStorm
http://www.clifford.at/icestorm/

IceStormのRaspberry Piへのインストール例
http://cellspe.matrix.jp/zerofpga/sjr_ice.html

まずiCE40HX-8Kのプログラミングモード設定を確認してください。
ボード上のジャンパ設定でSPI Flashに書き込むかCRAMに書き込むかを選択できます。

ターミナルで、

cd sc1_cpu

patch -p1 < patches/icestorm.patch

cd ice40hx8k

make

FPGAボードに書き込みます。（モードを間違えないように気をつけてください）

（CRAMに書き込む設定の場合）
make prog-ram

（SPI Flashに書き込む設定の場合）
make prog


* 命令配置制約について
命令配置制約が以下のように修正されます。（括弧内の数字はオリジナル版。これ以外の制約に関してはオリジナル版と同じ）

** 分岐命令(BC,BL,BA)、HALTの後の(2→)4命令は遅延スロットとなる。分岐命令の後(2→)4ステップの命令はそのまま実行され、(3→)5サイクル後に分岐先の命令が実行される。条件分岐の有無に関わらず遅延スロットの命令は実行される。混乱を避けるため通常は遅延スロットにはNOPを置く場合が多い。
例：
bc(-2); // if (R1 != 0) PC += -2
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0); // この命令まで実行されてから分岐先に飛ぶ

** mem_flag=1の命令で参照されるレジスタを操作する命令は、その命令の(2→)3サイクル以上前に置かなければいけない。
例：
mvi(16); // MVIレジスタR0に値16を代入
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0); // (1→)2サイクル待つ
nop(0,0,0, 0,0,0, 1,1,1); // d_addr, a_addr, b_addrにR0の値を代入

** 書き込み先がメモリの場合、書き換え後の値が読み込み可能となるのは(3→)4サイクル後である。ゆえにデータ依存性のある操作を連続して行う場合、(2→)3サイクル以上他の命令を挟まなければならない。
例：
R3=0; R4=1; d_addr=8; a_addr=8; であるとして、
add(3,3,4, 1,1,0, 1,1,0); // mem[8] = mem[8] + 1;
nop(0,0,0,0,0,0,0,0,0); // (2→)3サイクル待つ
nop(0,0,0,0,0,0,0,0,0); // ここにはNOP以外に無関係な他の命令を入れても良い
nop(0,0,0,0,0,0,0,0,0);
add(3,3,4, 1,1,0, 1,1,0); // mem[8] = mem[8] + 1;

** LOOP命令のループ終了位置オフセットはLOOP命令の(3→)5サイクル後以降に設定しなければいけない。
例：
mvi(0); // r0 = 0
add(8,0,0, 0,0,0, 0,0,0); // r8 = r0 + r0 = 0
mvi(7); // r0 = 7
add(3,0,8, 0,0,0, 0,0,0); // r3 = r0 + r8 = 7 : ループ回数 = 7 + 1
mvi(3); // r0 = 3
add(4,0,8, 0,0,0, 0,0,0); // r4 = r0 + r8 = 3 : ループ終了位置はLOOP命令の3サイクル後
add(5,8,8, 0,0,0, 0,0,0); // r5 = r8 + r8 = 0 : ループ終了位置からのジャンプ先オフセットは0 （同じ命令を繰り返す）
loop(); // ループ実行（予約）
nop(0,0,0,0,0,0,0,0,0); // ウェイト（他の無関係な命令を置いても良い）
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0);
nop(0,0,0,0,0,0,0,0,0);
add(9,9,9, 1,1,1, 1,1,1); // mem[d]=mem[a]+mem[b]; d+=r9; a+=r9; b+=r9; // この命令が8回繰り返される
